{"ast":null,"code":"import * as React from 'react';\nimport { Animated, DeviceEventEmitter, Dimensions, InteractionManager, KeyboardAvoidingView, Modal, PanResponder, BackHandler, Platform, TouchableWithoutFeedback, View } from 'react-native';\nimport * as PropTypes from 'prop-types';\nimport * as animatable from 'react-native-animatable';\nimport { initializeAnimations, buildAnimations, reversePercentage } from './utils';\nimport styles from './modal.style'; // Override default react-native-animatable animations\n\ninitializeAnimations();\n\nconst extractAnimationFromProps = props => ({\n  animationIn: props.animationIn,\n  animationOut: props.animationOut\n});\n\nexport class ReactNativeModal extends React.Component {\n  constructor(props) {\n    super(props); // We use an internal state for keeping track of the modal visibility: this allows us to keep\n    // the modal visible during the exit animation, even if the user has already change the\n    // isVisible prop to false.\n    // We store in the state the device width and height so that we can update the modal on\n    // device rotation.\n\n    this.state = {\n      showContent: true,\n      isVisible: false,\n      deviceWidth: Dimensions.get('window').width,\n      deviceHeight: Dimensions.get('window').height,\n      isSwipeable: !!this.props.swipeDirection,\n      pan: null\n    };\n    this.isTransitioning = false;\n    this.inSwipeClosingState = false;\n    this.currentSwipingDirection = null;\n    this.panResponder = null;\n\n    this.getDeviceHeight = () => this.props.deviceHeight || this.state.deviceHeight;\n\n    this.getDeviceWidth = () => this.props.deviceWidth || this.state.deviceWidth;\n\n    this.onBackButtonPress = () => {\n      if (this.props.onBackButtonPress && this.props.isVisible) {\n        this.props.onBackButtonPress();\n        return true;\n      }\n\n      return false;\n    };\n\n    this.buildPanResponder = () => {\n      let animEvt = null;\n      this.panResponder = PanResponder.create({\n        onMoveShouldSetPanResponder: (evt, gestureState) => {\n          // Use propagateSwipe to allow inner content to scroll. See PR:\n          // https://github.com/react-native-community/react-native-modal/pull/246\n          if (!this.props.propagateSwipe) {\n            // The number \"4\" is just a good tradeoff to make the panResponder\n            // work correctly even when the modal has touchable buttons.\n            // For reference:\n            // https://github.com/react-native-community/react-native-modal/pull/197\n            const shouldSetPanResponder = Math.abs(gestureState.dx) >= 4 || Math.abs(gestureState.dy) >= 4;\n\n            if (shouldSetPanResponder && this.props.onSwipeStart) {\n              this.props.onSwipeStart();\n            }\n\n            this.currentSwipingDirection = this.getSwipingDirection(gestureState);\n            animEvt = this.createAnimationEventForSwipe();\n            return shouldSetPanResponder;\n          }\n\n          return false;\n        },\n        onStartShouldSetPanResponder: e => {\n          const hasScrollableView = e._dispatchInstances && e._dispatchInstances.some(instance => /scrollview|flatlist/i.test(instance.type));\n\n          if (hasScrollableView && this.props.propagateSwipe && this.props.scrollTo && this.props.scrollOffset > 0) {\n            return false; // user needs to be able to scroll content back up\n          }\n\n          if (this.props.onSwipeStart) {\n            this.props.onSwipeStart();\n          } // Cleared so that onPanResponderMove can wait to have some delta\n          // to work with\n\n\n          this.currentSwipingDirection = null;\n          return true;\n        },\n        onPanResponderMove: (evt, gestureState) => {\n          // Using onStartShouldSetPanResponder we don't have any delta so we don't know\n          // The direction to which the user is swiping until some move have been done\n          if (!this.currentSwipingDirection) {\n            if (gestureState.dx === 0 && gestureState.dy === 0) {\n              return;\n            }\n\n            this.currentSwipingDirection = this.getSwipingDirection(gestureState);\n            animEvt = this.createAnimationEventForSwipe();\n          }\n\n          if (this.isSwipeDirectionAllowed(gestureState)) {\n            // Dim the background while swiping the modal\n            const newOpacityFactor = 1 - this.calcDistancePercentage(gestureState);\n            this.backdropRef && this.backdropRef.transitionTo({\n              opacity: this.props.backdropOpacity * newOpacityFactor\n            });\n            animEvt(evt, gestureState);\n\n            if (this.props.onSwipeMove) {\n              this.props.onSwipeMove(newOpacityFactor);\n            }\n          } else {\n            if (this.props.scrollTo) {\n              if (this.props.scrollHorizontal) {\n                let offsetX = -gestureState.dx;\n\n                if (offsetX > this.props.scrollOffsetMax) {\n                  offsetX -= (offsetX - this.props.scrollOffsetMax) / 2;\n                }\n\n                this.props.scrollTo({\n                  x: offsetX,\n                  animated: false\n                });\n              } else {\n                let offsetY = -gestureState.dy;\n\n                if (offsetY > this.props.scrollOffsetMax) {\n                  offsetY -= (offsetY - this.props.scrollOffsetMax) / 2;\n                }\n\n                this.props.scrollTo({\n                  y: offsetY,\n                  animated: false\n                });\n              }\n            }\n          }\n        },\n        onPanResponderRelease: (evt, gestureState) => {\n          // Call the onSwipe prop if the threshold has been exceeded on the right direction\n          const accDistance = this.getAccDistancePerDirection(gestureState);\n\n          if (accDistance > this.props.swipeThreshold && this.isSwipeDirectionAllowed(gestureState)) {\n            if (this.props.onSwipeComplete) {\n              this.inSwipeClosingState = true;\n              this.props.onSwipeComplete({\n                swipingDirection: this.getSwipingDirection(gestureState)\n              });\n              return;\n            } // Deprecated. Remove later.\n\n\n            if (this.props.onSwipe) {\n              this.inSwipeClosingState = true;\n              this.props.onSwipe();\n              return;\n            }\n          } //Reset backdrop opacity and modal position\n\n\n          if (this.props.onSwipeCancel) {\n            this.props.onSwipeCancel();\n          }\n\n          if (this.backdropRef) {\n            this.backdropRef.transitionTo({\n              opacity: this.props.backdropOpacity\n            });\n          }\n\n          Animated.spring(this.state.pan, {\n            toValue: {\n              x: 0,\n              y: 0\n            },\n            bounciness: 0,\n            useNativeDriver: false\n          }).start();\n\n          if (this.props.scrollTo) {\n            if (this.props.scrollOffset > this.props.scrollOffsetMax) {\n              this.props.scrollTo({\n                y: this.props.scrollOffsetMax,\n                animated: true\n              });\n            }\n          }\n        }\n      });\n    };\n\n    this.getAccDistancePerDirection = gestureState => {\n      switch (this.currentSwipingDirection) {\n        case 'up':\n          return -gestureState.dy;\n\n        case 'down':\n          return gestureState.dy;\n\n        case 'right':\n          return gestureState.dx;\n\n        case 'left':\n          return -gestureState.dx;\n\n        default:\n          return 0;\n      }\n    };\n\n    this.getSwipingDirection = gestureState => {\n      if (Math.abs(gestureState.dx) > Math.abs(gestureState.dy)) {\n        return gestureState.dx > 0 ? 'right' : 'left';\n      }\n\n      return gestureState.dy > 0 ? 'down' : 'up';\n    };\n\n    this.calcDistancePercentage = gestureState => {\n      switch (this.currentSwipingDirection) {\n        case 'down':\n          return (gestureState.moveY - gestureState.y0) / ((this.props.deviceHeight || this.state.deviceHeight) - gestureState.y0);\n\n        case 'up':\n          return reversePercentage(gestureState.moveY / gestureState.y0);\n\n        case 'left':\n          return reversePercentage(gestureState.moveX / gestureState.x0);\n\n        case 'right':\n          return (gestureState.moveX - gestureState.x0) / ((this.props.deviceWidth || this.state.deviceWidth) - gestureState.x0);\n\n        default:\n          return 0;\n      }\n    };\n\n    this.createAnimationEventForSwipe = () => {\n      if (this.currentSwipingDirection === 'right' || this.currentSwipingDirection === 'left') {\n        return Animated.event([null, {\n          dx: this.state.pan.x\n        }], {\n          useNativeDriver: false\n        });\n      } else {\n        return Animated.event([null, {\n          dy: this.state.pan.y\n        }], {\n          useNativeDriver: false\n        });\n      }\n    };\n\n    this.isDirectionIncluded = direction => {\n      return Array.isArray(this.props.swipeDirection) ? this.props.swipeDirection.includes(direction) : this.props.swipeDirection === direction;\n    };\n\n    this.isSwipeDirectionAllowed = ({\n      dy,\n      dx\n    }) => {\n      const draggedDown = dy > 0;\n      const draggedUp = dy < 0;\n      const draggedLeft = dx < 0;\n      const draggedRight = dx > 0;\n\n      if (this.currentSwipingDirection === 'up' && this.isDirectionIncluded('up') && draggedUp) {\n        return true;\n      } else if (this.currentSwipingDirection === 'down' && this.isDirectionIncluded('down') && draggedDown) {\n        return true;\n      } else if (this.currentSwipingDirection === 'right' && this.isDirectionIncluded('right') && draggedRight) {\n        return true;\n      } else if (this.currentSwipingDirection === 'left' && this.isDirectionIncluded('left') && draggedLeft) {\n        return true;\n      }\n\n      return false;\n    };\n\n    this.handleDimensionsUpdate = () => {\n      if (!this.props.deviceHeight && !this.props.deviceWidth) {\n        // Here we update the device dimensions in the state if the layout changed\n        // (triggering a render)\n        const deviceWidth = Dimensions.get('window').width;\n        const deviceHeight = Dimensions.get('window').height;\n\n        if (deviceWidth !== this.state.deviceWidth || deviceHeight !== this.state.deviceHeight) {\n          this.setState({\n            deviceWidth,\n            deviceHeight\n          });\n        }\n      }\n    };\n\n    this.open = () => {\n      if (this.isTransitioning) {\n        return;\n      }\n\n      this.isTransitioning = true;\n\n      if (this.backdropRef) {\n        this.backdropRef.transitionTo({\n          opacity: this.props.backdropOpacity\n        }, this.props.backdropTransitionInTiming);\n      } // This is for resetting the pan position,otherwise the modal gets stuck\n      // at the last released position when you try to open it.\n      // TODO: Could certainly be improved - no idea for the moment.\n\n\n      if (this.state.isSwipeable) {\n        this.state.pan.setValue({\n          x: 0,\n          y: 0\n        });\n      }\n\n      if (this.contentRef) {\n        this.props.onModalWillShow && this.props.onModalWillShow();\n        const interactionHandle = InteractionManager.createInteractionHandle();\n        this.contentRef.animate(this.animationIn, this.props.animationInTiming).then(() => {\n          this.isTransitioning = false;\n          InteractionManager.clearInteractionHandle(interactionHandle);\n\n          if (!this.props.isVisible) {\n            this.close();\n          } else {\n            this.props.onModalShow();\n          }\n        });\n      }\n    };\n\n    this.close = () => {\n      if (this.isTransitioning) {\n        return;\n      }\n\n      this.isTransitioning = true;\n\n      if (this.backdropRef) {\n        this.backdropRef.transitionTo({\n          opacity: 0\n        }, this.props.backdropTransitionOutTiming);\n      }\n\n      let animationOut = this.animationOut;\n\n      if (this.inSwipeClosingState) {\n        this.inSwipeClosingState = false;\n\n        if (this.currentSwipingDirection === 'up') {\n          animationOut = 'slideOutUp';\n        } else if (this.currentSwipingDirection === 'down') {\n          animationOut = 'slideOutDown';\n        } else if (this.currentSwipingDirection === 'right') {\n          animationOut = 'slideOutRight';\n        } else if (this.currentSwipingDirection === 'left') {\n          animationOut = 'slideOutLeft';\n        }\n      }\n\n      if (this.contentRef) {\n        this.props.onModalWillHide && this.props.onModalWillHide();\n        const interactionHandle = InteractionManager.createInteractionHandle();\n        this.contentRef.animate(animationOut, this.props.animationOutTiming).then(() => {\n          this.isTransitioning = false;\n          InteractionManager.clearInteractionHandle(interactionHandle);\n\n          if (this.props.isVisible) {\n            this.open();\n          } else {\n            this.setState({\n              showContent: false\n            }, () => {\n              this.setState({\n                isVisible: false\n              }, () => {\n                this.props.onModalHide();\n              });\n            });\n          }\n        });\n      }\n    };\n\n    this.makeBackdrop = () => {\n      if (!this.props.hasBackdrop) {\n        return null;\n      }\n\n      if (this.props.customBackdrop && !React.isValidElement(this.props.customBackdrop)) {\n        console.warn('Invalid customBackdrop element passed to Modal. You must provide a valid React element.');\n      }\n\n      const {\n        customBackdrop,\n        backdropColor,\n        useNativeDriver,\n        useNativeDriverForBackdrop,\n        onBackdropPress\n      } = this.props;\n      const hasCustomBackdrop = !!this.props.customBackdrop;\n      const backdropComputedStyle = [{\n        width: this.getDeviceWidth(),\n        height: this.getDeviceHeight(),\n        backgroundColor: this.state.showContent && !hasCustomBackdrop ? backdropColor : 'transparent'\n      }];\n      const backdropWrapper = React.createElement(animatable.View, {\n        ref: ref => this.backdropRef = ref,\n        useNativeDriver: useNativeDriverForBackdrop !== undefined ? useNativeDriverForBackdrop : useNativeDriver,\n        style: [styles.backdrop, backdropComputedStyle]\n      }, hasCustomBackdrop && customBackdrop);\n\n      if (hasCustomBackdrop) {\n        // The user will handle backdrop presses himself\n        return backdropWrapper;\n      } // If there's no custom backdrop, handle presses with\n      // TouchableWithoutFeedback\n\n\n      return React.createElement(TouchableWithoutFeedback, {\n        onPress: onBackdropPress\n      }, backdropWrapper);\n    };\n\n    const {\n      animationIn,\n      animationOut\n    } = buildAnimations(extractAnimationFromProps(props));\n    this.animationIn = animationIn;\n    this.animationOut = animationOut;\n\n    if (this.state.isSwipeable) {\n      this.state = { ...this.state,\n        pan: new Animated.ValueXY()\n      };\n      this.buildPanResponder();\n    }\n\n    if (props.isVisible) {\n      this.state = { ...this.state,\n        isVisible: true,\n        showContent: true\n      };\n    }\n  }\n\n  static getDerivedStateFromProps(nextProps, state) {\n    if (!state.isVisible && nextProps.isVisible) {\n      return {\n        isVisible: true,\n        showContent: true\n      };\n    }\n\n    return null;\n  }\n\n  componentDidMount() {\n    // Show deprecation message\n    if (this.props.onSwipe) {\n      console.warn('`<Modal onSwipe=\"...\" />` is deprecated and will be removed starting from 13.0.0. Use `<Modal onSwipeComplete=\"...\" />` instead.');\n    }\n\n    DeviceEventEmitter.addListener('didUpdateDimensions', this.handleDimensionsUpdate);\n\n    if (this.state.isVisible) {\n      this.open();\n    }\n\n    BackHandler.addEventListener('hardwareBackPress', this.onBackButtonPress);\n  }\n\n  componentWillUnmount() {\n    BackHandler.removeEventListener('hardwareBackPress', this.onBackButtonPress);\n    DeviceEventEmitter.removeListener('didUpdateDimensions', this.handleDimensionsUpdate);\n  }\n\n  componentDidUpdate(prevProps) {\n    // If the animations have been changed then rebuild them to make sure we're\n    // using the most up-to-date ones\n    if (this.props.animationIn !== prevProps.animationIn || this.props.animationOut !== prevProps.animationOut) {\n      const {\n        animationIn,\n        animationOut\n      } = buildAnimations(extractAnimationFromProps(this.props));\n      this.animationIn = animationIn;\n      this.animationOut = animationOut;\n    } // If backdrop opacity has been changed then make sure to update it\n\n\n    if (this.props.backdropOpacity !== prevProps.backdropOpacity && this.backdropRef) {\n      this.backdropRef.transitionTo({\n        opacity: this.props.backdropOpacity\n      }, this.props.backdropTransitionInTiming);\n    } // On modal open request, we slide the view up and fade in the backdrop\n\n\n    if (this.props.isVisible && !prevProps.isVisible) {\n      this.open();\n    } else if (!this.props.isVisible && prevProps.isVisible) {\n      // On modal close request, we slide the view down and fade out the backdrop\n      this.close();\n    }\n  }\n\n  render() {\n    /* eslint-disable @typescript-eslint/no-unused-vars */\n    const {\n      animationIn,\n      animationInTiming,\n      animationOut,\n      animationOutTiming,\n      avoidKeyboard,\n      coverScreen,\n      hasBackdrop,\n      backdropColor,\n      backdropOpacity,\n      backdropTransitionInTiming,\n      backdropTransitionOutTiming,\n      customBackdrop,\n      children,\n      isVisible,\n      onModalShow,\n      onBackButtonPress,\n      useNativeDriver,\n      propagateSwipe,\n      style,\n      ...otherProps\n    } = this.props;\n    const {\n      testID,\n      ...containerProps\n    } = otherProps;\n    const computedStyle = [{\n      margin: this.getDeviceWidth() * 0.05,\n      transform: [{\n        translateY: 0\n      }]\n    }, styles.content, style];\n    let panHandlers = {};\n    let panPosition = {};\n\n    if (this.state.isSwipeable) {\n      panHandlers = { ...this.panResponder.panHandlers\n      };\n\n      if (useNativeDriver) {\n        panPosition = {\n          transform: this.state.pan.getTranslateTransform()\n        };\n      } else {\n        panPosition = this.state.pan.getLayout();\n      }\n    } // The user might decide not to show the modal while it is animating\n    // to enhance performance.\n\n\n    const _children = this.props.hideModalContentWhileAnimating && this.props.useNativeDriver && !this.state.showContent ? React.createElement(animatable.View, null) : children;\n\n    const containerView = React.createElement(animatable.View, Object.assign({}, panHandlers, {\n      ref: ref => this.contentRef = ref,\n      style: [panPosition, computedStyle],\n      pointerEvents: \"box-none\",\n      useNativeDriver: useNativeDriver\n    }, containerProps), _children); // If coverScreen is set to false by the user\n    // we render the modal inside the parent view directly\n\n    if (!coverScreen && this.state.isVisible) {\n      return React.createElement(View, {\n        pointerEvents: \"box-none\",\n        style: [styles.backdrop, styles.containerBox]\n      }, this.makeBackdrop(), containerView);\n    }\n\n    return React.createElement(Modal, Object.assign({\n      transparent: true,\n      animationType: 'none',\n      visible: this.state.isVisible,\n      onRequestClose: onBackButtonPress\n    }, otherProps), this.makeBackdrop(), avoidKeyboard ? React.createElement(KeyboardAvoidingView, {\n      behavior: Platform.OS === 'ios' ? 'padding' : undefined,\n      pointerEvents: \"box-none\",\n      style: computedStyle.concat([{\n        margin: 0\n      }])\n    }, containerView) : containerView);\n  }\n\n}\nReactNativeModal.propTypes = {\n  animationIn: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),\n  animationInTiming: PropTypes.number,\n  animationOut: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),\n  animationOutTiming: PropTypes.number,\n  avoidKeyboard: PropTypes.bool,\n  coverScreen: PropTypes.bool,\n  hasBackdrop: PropTypes.bool,\n  backdropColor: PropTypes.string,\n  backdropOpacity: PropTypes.number,\n  backdropTransitionInTiming: PropTypes.number,\n  backdropTransitionOutTiming: PropTypes.number,\n  customBackdrop: PropTypes.node,\n  children: PropTypes.node.isRequired,\n  deviceHeight: PropTypes.number,\n  deviceWidth: PropTypes.number,\n  isVisible: PropTypes.bool.isRequired,\n  hideModalContentWhileAnimating: PropTypes.bool,\n  propagateSwipe: PropTypes.bool,\n  onModalShow: PropTypes.func,\n  onModalWillShow: PropTypes.func,\n  onModalHide: PropTypes.func,\n  onModalWillHide: PropTypes.func,\n  onBackButtonPress: PropTypes.func,\n  onBackdropPress: PropTypes.func,\n  onSwipeStart: PropTypes.func,\n  onSwipeMove: PropTypes.func,\n  onSwipeComplete: PropTypes.func,\n  onSwipeCancel: PropTypes.func,\n  swipeThreshold: PropTypes.number,\n  swipeDirection: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOf(['up', 'down', 'left', 'right'])), PropTypes.oneOf(['up', 'down', 'left', 'right'])]),\n  useNativeDriver: PropTypes.bool,\n  useNativeDriverForBackdrop: PropTypes.bool,\n  style: PropTypes.any,\n  scrollTo: PropTypes.func,\n  scrollOffset: PropTypes.number,\n  scrollOffsetMax: PropTypes.number,\n  scrollHorizontal: PropTypes.bool,\n  supportedOrientations: PropTypes.arrayOf(PropTypes.oneOf(['portrait', 'portrait-upside-down', 'landscape', 'landscape-left', 'landscape-right']))\n};\nReactNativeModal.defaultProps = {\n  animationIn: 'slideInUp',\n  animationInTiming: 300,\n  animationOut: 'slideOutDown',\n  animationOutTiming: 300,\n  avoidKeyboard: false,\n  coverScreen: true,\n  hasBackdrop: true,\n  backdropColor: 'black',\n  backdropOpacity: 0.7,\n  backdropTransitionInTiming: 300,\n  backdropTransitionOutTiming: 300,\n  customBackdrop: null,\n  useNativeDriver: false,\n  deviceHeight: null,\n  deviceWidth: null,\n  hideModalContentWhileAnimating: false,\n  propagateSwipe: false,\n  isVisible: false,\n  onModalShow: () => null,\n  onModalWillShow: () => null,\n  onModalHide: () => null,\n  onModalWillHide: () => null,\n  onBackdropPress: () => null,\n  onBackButtonPress: () => null,\n  swipeThreshold: 100,\n  scrollTo: null,\n  scrollOffset: 0,\n  scrollOffsetMax: 0,\n  scrollHorizontal: false,\n  supportedOrientations: ['portrait', 'landscape']\n};\nexport default ReactNativeModal;","map":{"version":3,"sources":["D:/course/client/node_modules/react-native-modal/dist/modal.js"],"names":["React","Animated","DeviceEventEmitter","Dimensions","InteractionManager","KeyboardAvoidingView","Modal","PanResponder","BackHandler","Platform","TouchableWithoutFeedback","View","PropTypes","animatable","initializeAnimations","buildAnimations","reversePercentage","styles","extractAnimationFromProps","props","animationIn","animationOut","ReactNativeModal","Component","constructor","state","showContent","isVisible","deviceWidth","get","width","deviceHeight","height","isSwipeable","swipeDirection","pan","isTransitioning","inSwipeClosingState","currentSwipingDirection","panResponder","getDeviceHeight","getDeviceWidth","onBackButtonPress","buildPanResponder","animEvt","create","onMoveShouldSetPanResponder","evt","gestureState","propagateSwipe","shouldSetPanResponder","Math","abs","dx","dy","onSwipeStart","getSwipingDirection","createAnimationEventForSwipe","onStartShouldSetPanResponder","e","hasScrollableView","_dispatchInstances","some","instance","test","type","scrollTo","scrollOffset","onPanResponderMove","isSwipeDirectionAllowed","newOpacityFactor","calcDistancePercentage","backdropRef","transitionTo","opacity","backdropOpacity","onSwipeMove","scrollHorizontal","offsetX","scrollOffsetMax","x","animated","offsetY","y","onPanResponderRelease","accDistance","getAccDistancePerDirection","swipeThreshold","onSwipeComplete","swipingDirection","onSwipe","onSwipeCancel","spring","toValue","bounciness","useNativeDriver","start","moveY","y0","moveX","x0","event","isDirectionIncluded","direction","Array","isArray","includes","draggedDown","draggedUp","draggedLeft","draggedRight","handleDimensionsUpdate","setState","open","backdropTransitionInTiming","setValue","contentRef","onModalWillShow","interactionHandle","createInteractionHandle","animate","animationInTiming","then","clearInteractionHandle","close","onModalShow","backdropTransitionOutTiming","onModalWillHide","animationOutTiming","onModalHide","makeBackdrop","hasBackdrop","customBackdrop","isValidElement","console","warn","backdropColor","useNativeDriverForBackdrop","onBackdropPress","hasCustomBackdrop","backdropComputedStyle","backgroundColor","backdropWrapper","createElement","ref","undefined","style","backdrop","onPress","ValueXY","getDerivedStateFromProps","nextProps","componentDidMount","addListener","addEventListener","componentWillUnmount","removeEventListener","removeListener","componentDidUpdate","prevProps","render","avoidKeyboard","coverScreen","children","otherProps","testID","containerProps","computedStyle","margin","transform","translateY","content","panHandlers","panPosition","getTranslateTransform","getLayout","_children","hideModalContentWhileAnimating","containerView","Object","assign","pointerEvents","containerBox","transparent","animationType","visible","onRequestClose","behavior","OS","concat","propTypes","oneOfType","string","object","number","bool","node","isRequired","func","arrayOf","oneOf","any","supportedOrientations","defaultProps"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { Animated, DeviceEventEmitter, Dimensions, InteractionManager, KeyboardAvoidingView, Modal, PanResponder, BackHandler, Platform, TouchableWithoutFeedback, View, } from 'react-native';\nimport * as PropTypes from 'prop-types';\nimport * as animatable from 'react-native-animatable';\nimport { initializeAnimations, buildAnimations, reversePercentage, } from './utils';\nimport styles from './modal.style';\n// Override default react-native-animatable animations\ninitializeAnimations();\nconst extractAnimationFromProps = (props) => ({\n    animationIn: props.animationIn,\n    animationOut: props.animationOut,\n});\nexport class ReactNativeModal extends React.Component {\n    constructor(props) {\n        super(props);\n        // We use an internal state for keeping track of the modal visibility: this allows us to keep\n        // the modal visible during the exit animation, even if the user has already change the\n        // isVisible prop to false.\n        // We store in the state the device width and height so that we can update the modal on\n        // device rotation.\n        this.state = {\n            showContent: true,\n            isVisible: false,\n            deviceWidth: Dimensions.get('window').width,\n            deviceHeight: Dimensions.get('window').height,\n            isSwipeable: !!this.props.swipeDirection,\n            pan: null,\n        };\n        this.isTransitioning = false;\n        this.inSwipeClosingState = false;\n        this.currentSwipingDirection = null;\n        this.panResponder = null;\n        this.getDeviceHeight = () => this.props.deviceHeight || this.state.deviceHeight;\n        this.getDeviceWidth = () => this.props.deviceWidth || this.state.deviceWidth;\n        this.onBackButtonPress = () => {\n            if (this.props.onBackButtonPress && this.props.isVisible) {\n                this.props.onBackButtonPress();\n                return true;\n            }\n            return false;\n        };\n        this.buildPanResponder = () => {\n            let animEvt = null;\n            this.panResponder = PanResponder.create({\n                onMoveShouldSetPanResponder: (evt, gestureState) => {\n                    // Use propagateSwipe to allow inner content to scroll. See PR:\n                    // https://github.com/react-native-community/react-native-modal/pull/246\n                    if (!this.props.propagateSwipe) {\n                        // The number \"4\" is just a good tradeoff to make the panResponder\n                        // work correctly even when the modal has touchable buttons.\n                        // For reference:\n                        // https://github.com/react-native-community/react-native-modal/pull/197\n                        const shouldSetPanResponder = Math.abs(gestureState.dx) >= 4 || Math.abs(gestureState.dy) >= 4;\n                        if (shouldSetPanResponder && this.props.onSwipeStart) {\n                            this.props.onSwipeStart();\n                        }\n                        this.currentSwipingDirection = this.getSwipingDirection(gestureState);\n                        animEvt = this.createAnimationEventForSwipe();\n                        return shouldSetPanResponder;\n                    }\n                    return false;\n                },\n                onStartShouldSetPanResponder: (e) => {\n                    const hasScrollableView = e._dispatchInstances &&\n                        e._dispatchInstances.some((instance) => /scrollview|flatlist/i.test(instance.type));\n                    if (hasScrollableView &&\n                        this.props.propagateSwipe &&\n                        this.props.scrollTo &&\n                        this.props.scrollOffset > 0) {\n                        return false; // user needs to be able to scroll content back up\n                    }\n                    if (this.props.onSwipeStart) {\n                        this.props.onSwipeStart();\n                    }\n                    // Cleared so that onPanResponderMove can wait to have some delta\n                    // to work with\n                    this.currentSwipingDirection = null;\n                    return true;\n                },\n                onPanResponderMove: (evt, gestureState) => {\n                    // Using onStartShouldSetPanResponder we don't have any delta so we don't know\n                    // The direction to which the user is swiping until some move have been done\n                    if (!this.currentSwipingDirection) {\n                        if (gestureState.dx === 0 && gestureState.dy === 0) {\n                            return;\n                        }\n                        this.currentSwipingDirection = this.getSwipingDirection(gestureState);\n                        animEvt = this.createAnimationEventForSwipe();\n                    }\n                    if (this.isSwipeDirectionAllowed(gestureState)) {\n                        // Dim the background while swiping the modal\n                        const newOpacityFactor = 1 - this.calcDistancePercentage(gestureState);\n                        this.backdropRef &&\n                            this.backdropRef.transitionTo({\n                                opacity: this.props.backdropOpacity * newOpacityFactor,\n                            });\n                        animEvt(evt, gestureState);\n                        if (this.props.onSwipeMove) {\n                            this.props.onSwipeMove(newOpacityFactor);\n                        }\n                    }\n                    else {\n                        if (this.props.scrollTo) {\n                            if (this.props.scrollHorizontal) {\n                                let offsetX = -gestureState.dx;\n                                if (offsetX > this.props.scrollOffsetMax) {\n                                    offsetX -= (offsetX - this.props.scrollOffsetMax) / 2;\n                                }\n                                this.props.scrollTo({ x: offsetX, animated: false });\n                            }\n                            else {\n                                let offsetY = -gestureState.dy;\n                                if (offsetY > this.props.scrollOffsetMax) {\n                                    offsetY -= (offsetY - this.props.scrollOffsetMax) / 2;\n                                }\n                                this.props.scrollTo({ y: offsetY, animated: false });\n                            }\n                        }\n                    }\n                },\n                onPanResponderRelease: (evt, gestureState) => {\n                    // Call the onSwipe prop if the threshold has been exceeded on the right direction\n                    const accDistance = this.getAccDistancePerDirection(gestureState);\n                    if (accDistance > this.props.swipeThreshold &&\n                        this.isSwipeDirectionAllowed(gestureState)) {\n                        if (this.props.onSwipeComplete) {\n                            this.inSwipeClosingState = true;\n                            this.props.onSwipeComplete({\n                                swipingDirection: this.getSwipingDirection(gestureState),\n                            });\n                            return;\n                        }\n                        // Deprecated. Remove later.\n                        if (this.props.onSwipe) {\n                            this.inSwipeClosingState = true;\n                            this.props.onSwipe();\n                            return;\n                        }\n                    }\n                    //Reset backdrop opacity and modal position\n                    if (this.props.onSwipeCancel) {\n                        this.props.onSwipeCancel();\n                    }\n                    if (this.backdropRef) {\n                        this.backdropRef.transitionTo({\n                            opacity: this.props.backdropOpacity,\n                        });\n                    }\n                    Animated.spring(this.state.pan, {\n                        toValue: { x: 0, y: 0 },\n                        bounciness: 0,\n                        useNativeDriver: false,\n                    }).start();\n                    if (this.props.scrollTo) {\n                        if (this.props.scrollOffset > this.props.scrollOffsetMax) {\n                            this.props.scrollTo({\n                                y: this.props.scrollOffsetMax,\n                                animated: true,\n                            });\n                        }\n                    }\n                },\n            });\n        };\n        this.getAccDistancePerDirection = (gestureState) => {\n            switch (this.currentSwipingDirection) {\n                case 'up':\n                    return -gestureState.dy;\n                case 'down':\n                    return gestureState.dy;\n                case 'right':\n                    return gestureState.dx;\n                case 'left':\n                    return -gestureState.dx;\n                default:\n                    return 0;\n            }\n        };\n        this.getSwipingDirection = (gestureState) => {\n            if (Math.abs(gestureState.dx) > Math.abs(gestureState.dy)) {\n                return gestureState.dx > 0 ? 'right' : 'left';\n            }\n            return gestureState.dy > 0 ? 'down' : 'up';\n        };\n        this.calcDistancePercentage = (gestureState) => {\n            switch (this.currentSwipingDirection) {\n                case 'down':\n                    return ((gestureState.moveY - gestureState.y0) /\n                        ((this.props.deviceHeight || this.state.deviceHeight) -\n                            gestureState.y0));\n                case 'up':\n                    return reversePercentage(gestureState.moveY / gestureState.y0);\n                case 'left':\n                    return reversePercentage(gestureState.moveX / gestureState.x0);\n                case 'right':\n                    return ((gestureState.moveX - gestureState.x0) /\n                        ((this.props.deviceWidth || this.state.deviceWidth) - gestureState.x0));\n                default:\n                    return 0;\n            }\n        };\n        this.createAnimationEventForSwipe = () => {\n            if (this.currentSwipingDirection === 'right' ||\n                this.currentSwipingDirection === 'left') {\n                return Animated.event([null, { dx: this.state.pan.x }], {\n                    useNativeDriver: false,\n                });\n            }\n            else {\n                return Animated.event([null, { dy: this.state.pan.y }], {\n                    useNativeDriver: false,\n                });\n            }\n        };\n        this.isDirectionIncluded = (direction) => {\n            return Array.isArray(this.props.swipeDirection)\n                ? this.props.swipeDirection.includes(direction)\n                : this.props.swipeDirection === direction;\n        };\n        this.isSwipeDirectionAllowed = ({ dy, dx }) => {\n            const draggedDown = dy > 0;\n            const draggedUp = dy < 0;\n            const draggedLeft = dx < 0;\n            const draggedRight = dx > 0;\n            if (this.currentSwipingDirection === 'up' &&\n                this.isDirectionIncluded('up') &&\n                draggedUp) {\n                return true;\n            }\n            else if (this.currentSwipingDirection === 'down' &&\n                this.isDirectionIncluded('down') &&\n                draggedDown) {\n                return true;\n            }\n            else if (this.currentSwipingDirection === 'right' &&\n                this.isDirectionIncluded('right') &&\n                draggedRight) {\n                return true;\n            }\n            else if (this.currentSwipingDirection === 'left' &&\n                this.isDirectionIncluded('left') &&\n                draggedLeft) {\n                return true;\n            }\n            return false;\n        };\n        this.handleDimensionsUpdate = () => {\n            if (!this.props.deviceHeight && !this.props.deviceWidth) {\n                // Here we update the device dimensions in the state if the layout changed\n                // (triggering a render)\n                const deviceWidth = Dimensions.get('window').width;\n                const deviceHeight = Dimensions.get('window').height;\n                if (deviceWidth !== this.state.deviceWidth ||\n                    deviceHeight !== this.state.deviceHeight) {\n                    this.setState({ deviceWidth, deviceHeight });\n                }\n            }\n        };\n        this.open = () => {\n            if (this.isTransitioning) {\n                return;\n            }\n            this.isTransitioning = true;\n            if (this.backdropRef) {\n                this.backdropRef.transitionTo({ opacity: this.props.backdropOpacity }, this.props.backdropTransitionInTiming);\n            }\n            // This is for resetting the pan position,otherwise the modal gets stuck\n            // at the last released position when you try to open it.\n            // TODO: Could certainly be improved - no idea for the moment.\n            if (this.state.isSwipeable) {\n                this.state.pan.setValue({ x: 0, y: 0 });\n            }\n            if (this.contentRef) {\n                this.props.onModalWillShow && this.props.onModalWillShow();\n                const interactionHandle = InteractionManager.createInteractionHandle();\n                this.contentRef\n                    .animate(this.animationIn, this.props.animationInTiming)\n                    .then(() => {\n                    this.isTransitioning = false;\n                    InteractionManager.clearInteractionHandle(interactionHandle);\n                    if (!this.props.isVisible) {\n                        this.close();\n                    }\n                    else {\n                        this.props.onModalShow();\n                    }\n                });\n            }\n        };\n        this.close = () => {\n            if (this.isTransitioning) {\n                return;\n            }\n            this.isTransitioning = true;\n            if (this.backdropRef) {\n                this.backdropRef.transitionTo({ opacity: 0 }, this.props.backdropTransitionOutTiming);\n            }\n            let animationOut = this.animationOut;\n            if (this.inSwipeClosingState) {\n                this.inSwipeClosingState = false;\n                if (this.currentSwipingDirection === 'up') {\n                    animationOut = 'slideOutUp';\n                }\n                else if (this.currentSwipingDirection === 'down') {\n                    animationOut = 'slideOutDown';\n                }\n                else if (this.currentSwipingDirection === 'right') {\n                    animationOut = 'slideOutRight';\n                }\n                else if (this.currentSwipingDirection === 'left') {\n                    animationOut = 'slideOutLeft';\n                }\n            }\n            if (this.contentRef) {\n                this.props.onModalWillHide && this.props.onModalWillHide();\n                const interactionHandle = InteractionManager.createInteractionHandle();\n                this.contentRef\n                    .animate(animationOut, this.props.animationOutTiming)\n                    .then(() => {\n                    this.isTransitioning = false;\n                    InteractionManager.clearInteractionHandle(interactionHandle);\n                    if (this.props.isVisible) {\n                        this.open();\n                    }\n                    else {\n                        this.setState({\n                            showContent: false,\n                        }, () => {\n                            this.setState({\n                                isVisible: false,\n                            }, () => {\n                                this.props.onModalHide();\n                            });\n                        });\n                    }\n                });\n            }\n        };\n        this.makeBackdrop = () => {\n            if (!this.props.hasBackdrop) {\n                return null;\n            }\n            if (this.props.customBackdrop &&\n                !React.isValidElement(this.props.customBackdrop)) {\n                console.warn('Invalid customBackdrop element passed to Modal. You must provide a valid React element.');\n            }\n            const { customBackdrop, backdropColor, useNativeDriver, useNativeDriverForBackdrop, onBackdropPress, } = this.props;\n            const hasCustomBackdrop = !!this.props.customBackdrop;\n            const backdropComputedStyle = [\n                {\n                    width: this.getDeviceWidth(),\n                    height: this.getDeviceHeight(),\n                    backgroundColor: this.state.showContent && !hasCustomBackdrop\n                        ? backdropColor\n                        : 'transparent',\n                },\n            ];\n            const backdropWrapper = (React.createElement(animatable.View, { ref: ref => (this.backdropRef = ref), useNativeDriver: useNativeDriverForBackdrop !== undefined\n                    ? useNativeDriverForBackdrop\n                    : useNativeDriver, style: [styles.backdrop, backdropComputedStyle] }, hasCustomBackdrop && customBackdrop));\n            if (hasCustomBackdrop) {\n                // The user will handle backdrop presses himself\n                return backdropWrapper;\n            }\n            // If there's no custom backdrop, handle presses with\n            // TouchableWithoutFeedback\n            return (React.createElement(TouchableWithoutFeedback, { onPress: onBackdropPress }, backdropWrapper));\n        };\n        const { animationIn, animationOut } = buildAnimations(extractAnimationFromProps(props));\n        this.animationIn = animationIn;\n        this.animationOut = animationOut;\n        if (this.state.isSwipeable) {\n            this.state = {\n                ...this.state,\n                pan: new Animated.ValueXY(),\n            };\n            this.buildPanResponder();\n        }\n        if (props.isVisible) {\n            this.state = {\n                ...this.state,\n                isVisible: true,\n                showContent: true,\n            };\n        }\n    }\n    static getDerivedStateFromProps(nextProps, state) {\n        if (!state.isVisible && nextProps.isVisible) {\n            return { isVisible: true, showContent: true };\n        }\n        return null;\n    }\n    componentDidMount() {\n        // Show deprecation message\n        if (this.props.onSwipe) {\n            console.warn('`<Modal onSwipe=\"...\" />` is deprecated and will be removed starting from 13.0.0. Use `<Modal onSwipeComplete=\"...\" />` instead.');\n        }\n        DeviceEventEmitter.addListener('didUpdateDimensions', this.handleDimensionsUpdate);\n        if (this.state.isVisible) {\n            this.open();\n        }\n        BackHandler.addEventListener('hardwareBackPress', this.onBackButtonPress);\n    }\n    componentWillUnmount() {\n        BackHandler.removeEventListener('hardwareBackPress', this.onBackButtonPress);\n        DeviceEventEmitter.removeListener('didUpdateDimensions', this.handleDimensionsUpdate);\n    }\n    componentDidUpdate(prevProps) {\n        // If the animations have been changed then rebuild them to make sure we're\n        // using the most up-to-date ones\n        if (this.props.animationIn !== prevProps.animationIn ||\n            this.props.animationOut !== prevProps.animationOut) {\n            const { animationIn, animationOut } = buildAnimations(extractAnimationFromProps(this.props));\n            this.animationIn = animationIn;\n            this.animationOut = animationOut;\n        }\n        // If backdrop opacity has been changed then make sure to update it\n        if (this.props.backdropOpacity !== prevProps.backdropOpacity &&\n            this.backdropRef) {\n            this.backdropRef.transitionTo({ opacity: this.props.backdropOpacity }, this.props.backdropTransitionInTiming);\n        }\n        // On modal open request, we slide the view up and fade in the backdrop\n        if (this.props.isVisible && !prevProps.isVisible) {\n            this.open();\n        }\n        else if (!this.props.isVisible && prevProps.isVisible) {\n            // On modal close request, we slide the view down and fade out the backdrop\n            this.close();\n        }\n    }\n    render() {\n        /* eslint-disable @typescript-eslint/no-unused-vars */\n        const { animationIn, animationInTiming, animationOut, animationOutTiming, avoidKeyboard, coverScreen, hasBackdrop, backdropColor, backdropOpacity, backdropTransitionInTiming, backdropTransitionOutTiming, customBackdrop, children, isVisible, onModalShow, onBackButtonPress, useNativeDriver, propagateSwipe, style, ...otherProps } = this.props;\n        const { testID, ...containerProps } = otherProps;\n        const computedStyle = [\n            { margin: this.getDeviceWidth() * 0.05, transform: [{ translateY: 0 }] },\n            styles.content,\n            style,\n        ];\n        let panHandlers = {};\n        let panPosition = {};\n        if (this.state.isSwipeable) {\n            panHandlers = { ...this.panResponder.panHandlers };\n            if (useNativeDriver) {\n                panPosition = {\n                    transform: this.state.pan.getTranslateTransform(),\n                };\n            }\n            else {\n                panPosition = this.state.pan.getLayout();\n            }\n        }\n        // The user might decide not to show the modal while it is animating\n        // to enhance performance.\n        const _children = this.props.hideModalContentWhileAnimating &&\n            this.props.useNativeDriver &&\n            !this.state.showContent ? (React.createElement(animatable.View, null)) : (children);\n        const containerView = (React.createElement(animatable.View, Object.assign({}, panHandlers, { ref: ref => (this.contentRef = ref), style: [panPosition, computedStyle], pointerEvents: \"box-none\", useNativeDriver: useNativeDriver }, containerProps), _children));\n        // If coverScreen is set to false by the user\n        // we render the modal inside the parent view directly\n        if (!coverScreen && this.state.isVisible) {\n            return (React.createElement(View, { pointerEvents: \"box-none\", style: [styles.backdrop, styles.containerBox] },\n                this.makeBackdrop(),\n                containerView));\n        }\n        return (React.createElement(Modal, Object.assign({ transparent: true, animationType: 'none', visible: this.state.isVisible, onRequestClose: onBackButtonPress }, otherProps),\n            this.makeBackdrop(),\n            avoidKeyboard ? (React.createElement(KeyboardAvoidingView, { behavior: Platform.OS === 'ios' ? 'padding' : undefined, pointerEvents: \"box-none\", style: computedStyle.concat([{ margin: 0 }]) }, containerView)) : (containerView)));\n    }\n}\nReactNativeModal.propTypes = {\n    animationIn: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),\n    animationInTiming: PropTypes.number,\n    animationOut: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),\n    animationOutTiming: PropTypes.number,\n    avoidKeyboard: PropTypes.bool,\n    coverScreen: PropTypes.bool,\n    hasBackdrop: PropTypes.bool,\n    backdropColor: PropTypes.string,\n    backdropOpacity: PropTypes.number,\n    backdropTransitionInTiming: PropTypes.number,\n    backdropTransitionOutTiming: PropTypes.number,\n    customBackdrop: PropTypes.node,\n    children: PropTypes.node.isRequired,\n    deviceHeight: PropTypes.number,\n    deviceWidth: PropTypes.number,\n    isVisible: PropTypes.bool.isRequired,\n    hideModalContentWhileAnimating: PropTypes.bool,\n    propagateSwipe: PropTypes.bool,\n    onModalShow: PropTypes.func,\n    onModalWillShow: PropTypes.func,\n    onModalHide: PropTypes.func,\n    onModalWillHide: PropTypes.func,\n    onBackButtonPress: PropTypes.func,\n    onBackdropPress: PropTypes.func,\n    onSwipeStart: PropTypes.func,\n    onSwipeMove: PropTypes.func,\n    onSwipeComplete: PropTypes.func,\n    onSwipeCancel: PropTypes.func,\n    swipeThreshold: PropTypes.number,\n    swipeDirection: PropTypes.oneOfType([\n        PropTypes.arrayOf(PropTypes.oneOf(['up', 'down', 'left', 'right'])),\n        PropTypes.oneOf(['up', 'down', 'left', 'right']),\n    ]),\n    useNativeDriver: PropTypes.bool,\n    useNativeDriverForBackdrop: PropTypes.bool,\n    style: PropTypes.any,\n    scrollTo: PropTypes.func,\n    scrollOffset: PropTypes.number,\n    scrollOffsetMax: PropTypes.number,\n    scrollHorizontal: PropTypes.bool,\n    supportedOrientations: PropTypes.arrayOf(PropTypes.oneOf([\n        'portrait',\n        'portrait-upside-down',\n        'landscape',\n        'landscape-left',\n        'landscape-right',\n    ])),\n};\nReactNativeModal.defaultProps = {\n    animationIn: 'slideInUp',\n    animationInTiming: 300,\n    animationOut: 'slideOutDown',\n    animationOutTiming: 300,\n    avoidKeyboard: false,\n    coverScreen: true,\n    hasBackdrop: true,\n    backdropColor: 'black',\n    backdropOpacity: 0.7,\n    backdropTransitionInTiming: 300,\n    backdropTransitionOutTiming: 300,\n    customBackdrop: null,\n    useNativeDriver: false,\n    deviceHeight: null,\n    deviceWidth: null,\n    hideModalContentWhileAnimating: false,\n    propagateSwipe: false,\n    isVisible: false,\n    onModalShow: () => null,\n    onModalWillShow: () => null,\n    onModalHide: () => null,\n    onModalWillHide: () => null,\n    onBackdropPress: () => null,\n    onBackButtonPress: () => null,\n    swipeThreshold: 100,\n    scrollTo: null,\n    scrollOffset: 0,\n    scrollOffsetMax: 0,\n    scrollHorizontal: false,\n    supportedOrientations: ['portrait', 'landscape'],\n};\nexport default ReactNativeModal;\n"]},"metadata":{},"sourceType":"module"}